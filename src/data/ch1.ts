
import { ContentBlock } from '../../types';

export const CH1_DATA: Record<string, ContentBlock> = {
  "ch1": {
    id: "ch1",
    type: "chapter",
    title: "第1章 绪论",
    description: "本章主要考查计算机的基本组成框架与性能指标计算。重点在于冯·诺依曼结构特点、五大部件功能以及性能公式（CPU时间、CPI、MIPS）的应用。",
    childrenIds: ["1.1", "1.2", "1.3", "1.4", "1.5", "1.6"]
  },
  "1.1": {
    id: "1.1",
    type: "section",
    title: "1.1 计算机的基本概念",
    description: "理解计算机系统的核心工作原理：存储程序。",
    childrenIds: ["1.1.1", "1.1.2"]
  },
  "1.1.1": {
    id: "1.1.1",
    type: "subsection",
    title: "1.1.1 存储程序工作方式",
    diagram: "VonNeumannArch",
    keyPoints: [
      {
        title: "冯·诺依曼体制核心 (Stored Program Concept)",
        content: `这是计算机组成原理中最基础的理论基石，由美籍匈牙利数学家冯·诺依曼于1945年提出。
核心思想包括：
1. **二进制表示**：计算机内部的指令和数据均采用二进制代码表示。这是因为二进制在物理上容易实现（高低电平、开关通断），且运算规则简单。
2. **存储程序**：程序的指令和数据预先存放在存储器中，计算机启动后，能够自动、连续地从存储器中取出指令并执行，而无需人工干预。
3. **五大部件**：计算机硬件由**运算器**、**控制器**、**存储器**、**输入设备**和**输出设备**五大部件组成。
4. **指令结构**：指令由**操作码**（表示做什么）和**地址码**（表示对谁做）组成。
5. **以运算器为中心**：早期的冯·诺依曼结构以运算器为中心，输入/输出数据都要经过运算器。`,
        isExamFocus: true
      },
      {
        title: "现代计算机结构的改进",
        content: `早期的“以运算器为中心”会导致运算器成为瓶颈。
**现代计算机结构**转变为**以存储器为中心**。
- I/O 设备可以直接与存储器交换数据（如 DMA 技术），减轻了 CPU 的负担。
- CPU = 运算器 + 控制器。`,
        isExamFocus: false
      }
    ],
    examples: [
      {
        question: "冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU如何区分它们？",
        solution: `CPU无法从形式上区分0和1到底是指令还是数据，而是通过**指令周期的时间阶段**来区分的。
- 在**取指周期**（Fetch Cycle）从存储器读出的信息被视为**指令**，流向控制器（指令寄存器 IR）。
- 在**执行周期**（Execute Cycle）从存储器读出的信息被视为**数据**，流向运算器或通用寄存器。`,
        tip: "这是一个经典简答题/选择题，务必理解“时间段”的概念。"
      }
    ]
  },
  "1.1.2": {
    id: "1.1.2",
    type: "subsection",
    title: "1.1.2 信息的数字化表示",
    keyPoints: [
      {
        title: "为什么使用二进制？",
        content: `1. **物理实现简单**：利用双稳态器件（如晶体管的导通/截止）表示0和1非常可靠。
2. **运算规则简单**：二进制的加法口诀只有四条，简化了运算器的逻辑设计。
3. **逻辑判断方便**：0和1正好对应逻辑代数中的“假”和“真”，便于实现逻辑运算。
4. **抗干扰能力强**：区分高低电平比区分十个电平容易得多，可靠性高。`
      }
    ]
  },
  "1.2": {
    id: "1.2",
    type: "section",
    title: "1.2 计算机系统的硬件和软件组成",
    childrenIds: ["1.2.1", "1.2.2"]
  },
  "1.2.1": {
    id: "1.2.1",
    type: "subsection",
    title: "1.2.1 计算机硬件系统",
    keyPoints: [
      {
        title: "五大部件详解",
        content: `1. **运算器 (ALU)**：负责算术运算（加减乘除）和逻辑运算（与或非）。核心部件是算术逻辑单元 ALU 和累加器 ACC。
2. **控制器 (CU)**：计算机的指挥中心。负责从内存取指令、分析指令、产生控制信号。包括程序计数器 PC、指令寄存器 IR、控制单元 CU。
3. **存储器 (Memory)**：
   - **主存 (Main Memory)**：CPU 直接访问，存放当前运行的程序和数据。由存储体、地址寄存器 MAR、数据寄存器 MDR 组成。
   - **辅存 (Auxiliary Memory)**：容量大、速度慢，用于长期保存。
4. **输入设备**：将人类可识别的信息转换为计算机能识别的二进制信息（键盘、鼠标）。
5. **输出设备**：将计算结果转换为人类可识别的形式（显示器、打印机）。`
      },
      {
        title: "CPU 的构成",
        content: `CPU (Central Processing Unit) = 运算器 + 控制器。
- **MAR (Memory Address Register)**：存储器地址寄存器，其位数决定了存储器的寻址范围（如10位地址线可寻址 1K）。
- **MDR (Memory Data Register)**：存储器数据寄存器，其位数通常等于存储字长。`
      }
    ]
  },
  "1.2.2": {
    id: "1.2.2",
    type: "subsection",
    title: "1.2.2 计算机软件系统",
    keyPoints: [
      {
        title: "系统软件 vs 应用软件",
        content: `1. **系统软件**：管理计算机资源、提供服务。
   - 操作系统 (OS)：Windows, Linux, macOS。
   - 语言处理程序：汇编程序、编译程序、解释程序。
   - 数据库管理系统 (DBMS)。
   - 服务程序：诊断、调试工具。
2. **应用软件**：用户为解决具体问题编写的程序。
   - Office, 游戏, 浏览器等。`
      }
    ]
  },
  "1.3": {
    id: "1.3",
    type: "section",
    title: "1.3 层次结构模型",
    childrenIds: ["1.3.1", "1.3.2", "1.3.3"]
  },
  "1.3.1": {
    id: "1.3.1",
    type: "subsection",
    title: "1.3.1 从计算机系统组成角度划分层次结构",
    keyPoints: [
      {
        title: "多级层次结构 (Hierarchy)",
        content: `计算机系统可以看作是一系列层级，每一层都建立在下层的基础上。
- **L0: 硬联逻辑层 (微程序机器层)**：由硬件门电路直接实现微指令。
- **L1: 传统机器语言层**：程序员用机器指令编写程序，由微程序解释执行。
- **L2: 操作系统层**：提供系统调用，管理资源。
- **L3: 汇编语言层**：使用助记符，由汇编程序翻译成机器语言。
- **L4: 高级语言层**：C++, Java, Python。由编译器或解释器处理。
- **L5: 应用语言层**：面向特定问题的语言。`,
        isExamFocus: true
      }
    ]
  },
  "1.3.2": {
    id: "1.3.2",
    type: "subsection",
    title: "1.3.2 从语言功能角度划分层次结构",
    keyPoints: [
      {
        title: "翻译 vs 解释",
        content: `高级语言程序（源程序）必须转换为机器语言（目标程序）才能执行。
- **编译 (Compiler)**：将源程序**一次性全部**翻译成目标程序，然后执行目标程序。执行速度快。 (C, C++)
- **解释 (Interpreter)**：将源程序**逐条**翻译并立即执行，不生成目标文件。便于调试，但速度慢。 (Python, JS)`
      }
    ]
  },
  "1.3.3": {
    id: "1.3.3",
    type: "subsection",
    title: "1.3.3 软件和硬件在逻辑上的等价",
    keyPoints: [
      {
        title: "软硬件逻辑等价性",
        content: `**原理**：任何操作可以由软件实现，也可以由硬件实现。
- **硬件实现**：速度快，成本高，灵活性差（如硬件浮点单元 FPU）。
- **软件实现**：速度慢，成本低，灵活性好（如软件模拟浮点运算）。
**设计决策**：根据性能、价格、实现难度进行折中。`
      }
    ]
  },
  "1.4": {
    id: "1.4",
    type: "section",
    title: "1.4 计算机的工作过程",
    childrenIds: ["1.4.1", "1.4.2"]
  },
  "1.4.1": {
    id: "1.4.1",
    type: "subsection",
    title: "1.4.1 处理问题的步骤",
    keyPoints: [
      {
        title: "从问题到结果",
        content: `1. **系统分析**：建立数学模型。
2. **算法设计**：确定计算步骤。
3. **编程**：使用高级语言编写源程序。
4. **编译/汇编**：翻译成机器目标代码。
5. **链接**：将库文件链接，生成可执行文件 (.exe)。
6. **运行**：操作系统加载程序到内存，CPU 执行。`
      }
    ]
  },
  "1.4.2": {
    id: "1.4.2",
    type: "subsection",
    title: "1.4.2 指令执行过程",
    keyPoints: [
      {
        title: "基本指令周期",
        content: `CPU 执行一条指令通常分为以下阶段：
1. **取指 (Fetch)**：PC -> MAR -> Memory -> MDR -> IR。PC 自增。
2. **译码 (Decode)**：CU 分析 IR 中的操作码，产生控制信号。
3. **执行 (Execute)**：ALU 进行运算。
4. **访存 (Memory)**：如果需要，访问内存读写数据。
5. **写回 (Write Back)**：将结果写回寄存器。`
      },
      {
        title: "取指周期微操作 (详细)",
        content: `(1) **PC -> MAR**：将程序计数器的内容送入地址寄存器。
(2) **M(MAR) -> MDR**：控制存储器读操作，将指令读入数据寄存器。
(3) **MDR -> IR**：将指令送入指令寄存器。
(4) **PC + 1 -> PC**：程序计数器加 1，指向下一条指令。`,
        isExamFocus: true
      }
    ]
  },
  "1.5": {
    id: "1.5",
    type: "section",
    title: "1.5 计算机的特点和性能指标",
    childrenIds: ["1.5.1", "1.5.2"]
  },
  "1.5.1": {
    id: "1.5.1",
    type: "subsection",
    title: "1.5.1 计算机的特点",
    keyPoints: [
      {
        title: "五大特点",
        content: `1. **运算速度快**：电子器件的高速开关特性。
2. **计算精度高**：受字长限制，但可通过多倍精度运算提高。
3. **记忆能力强**：海量存储。
4. **具有逻辑判断能力**：不仅能算术运算，还能进行逻辑比较和跳转。
5. **具有自动控制能力**：存储程序控制。`
      }
    ]
  },
  "1.5.2": {
    id: "1.5.2",
    type: "subsection",
    title: "1.5.2 计算机的性能指标",
    keyPoints: [
      {
        title: "基本指标",
        content: `1. **机器字长**：CPU 一次能处理的二进制数据的位数（如 32位、64位）。字长越长，精度越高，寻址范围越大。
2. **主频 (Clock Rate, f)**：CPU 的时钟频率，单位 Hz。主频越高，节拍越快。
3. **吞吐量 (Throughput)**：单位时间内处理的信息量。
4. **响应时间 (Response Time)**：从提交请求到得到结果的时间。`
      },
      {
        title: "CPU 性能公式 (必考)",
        content: `**1. CPI (Cycles Per Instruction)**
执行一条指令所需的时钟周期数。通常指平均 CPI。
$$CPI = \\frac{\\text{程序执行所需的总时钟周期数}}{\\text{指令条数}}$$

**2. CPU 执行时间 (CPU Time)**
$$T_{CPU} = \\text{总时钟周期数} \\times T_{clk} = \\frac{\\text{总时钟周期数}}{f}$$
$$T_{CPU} = \\frac{N \\times CPI}{f}$$
(其中 N 为指令条数，f 为主频)

**3. MIPS (Million Instructions Per Second)**
每秒执行多少百万条指令。
$$MIPS = \\frac{N}{T_{CPU} \\times 10^6} = \\frac{f}{CPI \\times 10^6}$$
注意：MIPS 并不完全代表性能，因为它不考虑不同指令的功能强弱。`,
        isExamFocus: true,
        formulas: [
          "CPU时间 = (指令条数 × CPI) / 主频",
          "MIPS = 主频 / (CPI × 10^6)",
          "CPI = Σ(CPI_i × 比例_i)"
        ]
      }
    ],
    examples: [
      {
        question: "某机主频 1.2GHz，指令序列包含 A, B, C 三类指令，占比分别为 50%, 30%, 20%，CPI 分别为 2, 3, 5。求程序的平均 CPI 和 MIPS。",
        solution: `**步骤 1：计算平均 CPI**
$$CPI_{avg} = \\sum (P_i \\times CPI_i)$$
$$CPI_{avg} = 0.5 \\times 2 + 0.3 \\times 3 + 0.2 \\times 5$$
$$CPI_{avg} = 1.0 + 0.9 + 1.0 = 2.9$$

**步骤 2：计算 MIPS**
$$f = 1.2 \\text{ GHz} = 1.2 \\times 10^9 \\text{ Hz}$$
$$MIPS = \\frac{f}{CPI \\times 10^6}$$
$$MIPS = \\frac{1.2 \\times 10^9}{2.9 \\times 10^6} \\approx 413.79$$

**答案**：平均 CPI 为 2.9，MIPS 约为 413.8。`,
        tip: "计算 MIPS 时，千万别忘了分母里的 10^6。主频单位要换算成 Hz。"
      }
    ]
  },
  "1.6": {
    id: "1.6",
    type: "section",
    title: "1.6 计算机的发展与应用",
    childrenIds: ["1.6.1", "1.6.2", "1.6.3"]
  },
  "1.6.1": {
    id: "1.6.1",
    type: "subsection",
    title: "1.6.1 计算机的发展历程",
    keyPoints: [
      {
        title: "四个时代",
        content: `1. **第一代 (1946-1957)**：电子管。体积大，耗电，运算慢。机器语言/汇编语言。
2. **第二代 (1958-1964)**：晶体管。体积减小，可靠性提高。高级语言 (Fortran)。
3. **第三代 (1965-1971)**：中小规模集成电路 (SSI/MSI)。操作系统出现。
4. **第四代 (1972-至今)**：大/超大规模集成电路 (LSI/VLSI)。微处理器诞生，个人电脑普及。`
      }
    ]
  },
  "1.6.2": {
    id: "1.6.2",
    type: "subsection",
    title: "1.6.2 计算机性能提高的技术",
    keyPoints: [
      {
        title: "摩尔定律 (Moore's Law)",
        content: "集成电路芯片上所集成的晶体管数目，每隔 18-24 个月翻一番，性能提升一倍，价格降低一半。"
      }
    ]
  },
  "1.6.3": {
    id: "1.6.3",
    type: "subsection",
    title: "1.6.3 计算机应用举例",
    keyPoints: [
      {
        title: "广泛应用",
        content: "科学计算（天气预报）、信息处理（数据库）、自动控制（工业）、辅助设计（CAD/CAM）、人工智能（AI）。"
      }
    ]
  }
};
