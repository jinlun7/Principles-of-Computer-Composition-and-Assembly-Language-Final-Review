
import { ContentBlock } from '../../types';

export const CH2_DATA: Record<string, ContentBlock> = {
  "ch2": {
    id: "ch2",
    type: "chapter",
    title: "第2章 信息表示",
    description: "本章是计算机组成的基石。重点掌握数值数据的机器码表示（原反补移）、定点数与浮点数（IEEE754）的转换与运算规则，以及字符编码标准。",
    childrenIds: ["2.1", "2.2", "2.3"]
  },
  "2.1": {
    id: "2.1",
    type: "section",
    title: "2.1 数值型数据的表示",
    childrenIds: ["2.1.1", "2.1.2"]
  },
  "2.1.1": {
    id: "2.1.1",
    type: "subsection",
    title: "2.1.1 带符号数的表示",
    diagram: "ComplementRing",
    keyPoints: [
      {
        title: "机器数与真值",
        content: `**真值**：带有“+”、“-”号的实际数值（如 -5, +3）。
**机器数**：在计算机内部使用的、符号位数字化的二进制数（如 10000101）。`
      },
      {
        title: "原码 (Sign-Magnitude)",
        content: `**定义**：最高位为符号位（0正1负），其余位为数值的绝对值。
**特点**：
- 直观，易于人理解。
- **0 有两种表示**：[+0]原 = 00000, [-0]原 = 10000。
- 加减法运算复杂（需要判断符号）。
**范围** (n+1位)：$-(2^n - 1) \\sim +(2^n - 1)$`
      },
      {
        title: "反码 (One's Complement)",
        content: `**定义**：
- 正数：同原码。
- 负数：符号位为1，数值位在原码基础上按位取反。
**特点**：
- **0 仍有两种表示**：[+0]反 = 00000, [-0]反 = 11111。
- 多用于系统环境设置，计算中很少直接使用。`
      },
      {
        title: "补码 (Two's Complement) —— 最重要",
        content: `**定义**：
- 正数：同原码。
- 负数：反码 + 1（符号位不变）。
**特点**：
- **0 只有一种表示**：[+0]补 = [-0]补 = 00000。
- **可以将减法转化为加法**：$A - B = A + (-B)$，即 $[A-B]_{补} = [A]_{补} + [-B]_{补}$。
- **符号位参与运算**。
**范围** (n+1位)：$-2^n \\sim +(2^n - 1)$。
*注意：多表示一个最小负数（如8位补码的 -128，10000000），该数没有对应的原码和反码。*`,
        isExamFocus: true
      },
      {
        title: "移码 (Bias)",
        content: `**定义**：通常用于浮点数的阶码。
$[x]_{移} = 2^n + x$ (其中 $2^n$ 为偏置值，n为数值位数)。
**特点**：
- 实际上就是补码的符号位取反。
- 保持了数据的大小顺序，便于比较大小。
- 0 只有一种表示。`
      }
    ],
    examples: [
      {
        question: "已知机器字长为 8 位，求 x = -100 (十进制) 的原码、反码和补码。",
        solution: `**1. 转二进制绝对值**
$|-100| = 100 = 64 + 32 + 4 = 01100100_2$

**2. 原码**
符号位变 1，数值位不变。
$[x]_{原} = 11100100$

**3. 反码**
负数原码符号位不变，数值位取反。
$[x]_{反} = 10011011$

**4. 补码**
反码末位 + 1。
$[x]_{补} = 10011011 + 1 = 10011100$`,
        tip: "对于特殊值 -128，只有补码能表示 (10000000)，原码和反码溢出。"
      }
    ]
  },
  "2.1.2": {
    id: "2.1.2",
    type: "subsection",
    title: "2.1.2 定点数与浮点数 (IEEE 754)",
    keyPoints: [
      {
        title: "定点数 (Fixed Point)",
        content: `小数点位置固定。
- **定点整数**：小数点在最低位之后（纯整数）。
- **定点小数**：小数点在符号位之后（纯小数）。
*缺点*：表示范围有限，难以适应科学计算中极大或极小的数。`
      },
      {
        title: "浮点数 (Floating Point)",
        content: `类似于科学计数法 $N = M \\times R^E$。
- **M (Mantissa)**：尾数，决定精度。
- **E (Exponent)**：阶码，决定范围。
- **R (Radix)**：基数，通常为 2（隐含）。`
      },
      {
        title: "IEEE 754 标准 (32位单精度)",
        content: `这是考试必考的重难点。
**格式**：1位符号 (S) + 8位阶码 (E) + 23位尾数 (M)
$$V = (-1)^S \\times 1.M \\times 2^{E-127}$$

**关键规则**：
1. **S (Sign)**：0正1负。
2. **E (Exponent)**：采用**移码**表示，偏置值为 **127**。
   - $E = \\text{真值指数} e + 127$。
3. **M (Mantissa)**：采用原码表示。因为规格化后最高位总是 1（$1.xxxxx$），所以**隐含**整数位的 1，只存储小数部分。`,
        isExamFocus: true,
        formulas: [
          "真值 = (-1)^S × 1.M × 2^(E-127)",
          "E = e + 127 (单精度)",
          "E = e + 1023 (双精度)"
        ]
      }
    ],
    examples: [
      {
        question: "将十进制数 -12.5 转换为 IEEE 754 单精度机器码（十六进制）。",
        solution: `**步骤 1：数值转二进制**
整数部分 $12 = 1100_2$
小数部分 $0.5 = 0.1_2$
绝对值 $12.5 = 1100.1_2$

**步骤 2：规格化 (科学计数法)**
$1100.1 = 1.1001 \\times 2^3$
- 符号 $S = 1$ (负数)
- 指数 $e = 3$
- 尾数部分 $1.1001$ (隐含整数1) -> 存储 $1001...$

**步骤 3：计算阶码**
$E = e + 127 = 3 + 127 = 130$
$130 = 128 + 2 = 10000010_2$

**步骤 4：拼接**
S (1位) | E (8位) | M (23位)
1 | 10000010 | 10010000000000000000000

**步骤 5：转十六进制**
1100 0001 0100 1000 ...
C    1    4    8    0000
结果：**C1480000 H**`,
        tip: "转换时注意阶码加 127，尾数左对齐补 0。"
      }
    ]
  },
  "2.2": {
    id: "2.2",
    type: "section",
    title: "2.2 字符的表示",
    childrenIds: ["2.2.1", "2.2.2", "2.2.3"]
  },
  "2.2.1": {
    id: "2.2.1",
    type: "subsection",
    title: "2.2.1 ASCII",
    keyPoints: [
      {
        title: "ASCII 码",
        content: `美国标准信息交换码。
- **7 位编码**：可以表示 128 个字符。
- **存储**：占用 1 个字节（8位），最高位通常为 0，或用作奇偶校验位。
- **常见值**：'0'=30H, 'A'=41H, 'a'=61H。小写字母比大写字母大 32 (20H)。`
      }
    ]
  },
  "2.2.2": {
    id: "2.2.2",
    type: "subsection",
    title: "2.2.2 Unicode 编码",
    keyPoints: [
      {
        title: "Unicode 与 UTF-8",
        content: `**Unicode**：为世界上所有字符分配唯一码点。
**UTF-8**：Unicode 的一种变长实现方式。
- 兼容 ASCII（1字节）。
- 中文通常占 3 字节。
- 无字节序（Endian）问题，网络传输首选。`
      }
    ]
  },
  "2.2.3": {
    id: "2.2.3",
    type: "subsection",
    title: "2.2.3 汉字编码简介",
    keyPoints: [
      {
        title: "汉字编码流程",
        content: `1. **输入码**：输入汉字的方法（拼音、五笔）。
2. **国标码 (交换码)**：GB2312。每个汉字占2字节。
3. **机内码 (存储)**：为了区分汉字和 ASCII，将国标码每个字节的最高位设为 1。
   $$机内码 = 国标码 + 8080H$$
4. **字形码 (输出)**：用于显示或打印的点阵信息（如 16x16 点阵）。`,
        isExamFocus: true
      }
    ]
  },
  "2.3": {
    id: "2.3",
    type: "section",
    title: "2.3 指令信息的表示",
    childrenIds: ["2.3.1", "2.3.2", "2.3.3", "2.3.4", "2.3.5", "2.3.6", "2.3.7"]
  },
  "2.3.1": {
    id: "2.3.1",
    type: "subsection",
    title: "2.3.1 指令格式",
    keyPoints: [
      {
        title: "基本格式",
        content: `指令 = 操作码 (Opcode) + 地址码 (Operand)。
- **操作码**：指出“做什么”（如 ADD, MOV）。
- **地址码**：指出“对谁做”（操作数地址、结果存放地址）。`
      },
      {
        title: "扩展操作码技术",
        content: `为了在指令字长固定的情况下增加指令数量，可以利用地址码的位空间来扩展操作码。
**原则**：短操作码指令的操作数不能是长操作码的前缀。
**规律**：使用频率高的指令分配短操作码，频率低的分配长操作码（类似哈夫曼编码思想）。`
      }
    ]
  },
  "2.3.2": {
    id: "2.3.2",
    type: "subsection",
    title: "2.3.2 常用寻址方式",
    keyPoints: [
      {
        title: "寻址方式大汇总",
        content: `**1. 立即寻址 (Immediate)**
操作数直接在指令中。
例：\`MOV AX, 2000H\`
速度快，但数的大小受限。

**2. 寄存器寻址 (Register)**
操作数在寄存器中。
例：\`MOV AX, BX\`
速度快，只需访问寄存器。

**3. 直接寻址 (Direct)**
指令包含有效地址 EA。
例：\`MOV AX, [2000H]\`
需访问一次内存。

**4. 寄存器间接寻址 (Register Indirect)**
寄存器存放有效地址。
例：\`MOV AX, [BX]\`
广泛用于访问数组、指针。

**5. 相对寻址 (Relative)**
EA = (PC) + 偏移量。
用于分支跳转指令 (JMP, LOOP)。有利于程序浮动。

**6. 基址/变址寻址 (Base/Indexed)**
EA = (基址Reg) + (变址Reg) + 偏移。
用于复杂的数组访问、堆栈操作。`,
        isExamFocus: true
      }
    ]
  },
  "2.3.3": { id: "2.3.3", type: "subsection", title: "2.3.3 指令类型", keyPoints: [{ title: "类型", content: "1. 数据传送 (MOV)\n2. 算术逻辑 (ADD, AND)\n3. 移位 (SHL)\n4. 转移 (JMP)\n5. 输入输出 (IN, OUT)" }] },
  "2.3.4": { id: "2.3.4", type: "subsection", title: "2.3.4 Pentium II 指令格式", keyPoints: [{ title: "特点", content: "变长指令，格式极复杂，向下兼容 8086。" }] },
  "2.3.5": {
    id: "2.3.5",
    type: "subsection",
    title: "2.3.5 RISC 概述",
    keyPoints: [
      {
        title: "CISC vs RISC",
        content: `**CISC (Complex Instruction Set Computer)**:
- 指令多、复杂、变长。
- 寻址方式多。
- 微程序控制为主。
- 代表：x86。

**RISC (Reduced Instruction Set Computer)**:
- 指令少、简单、定长 (通常32位)。
- 寻址方式少。
- 只有 Load/Store 指令能访问内存。
- 硬布线控制为主，流水线优化好。
- 代表：ARM, MIPS, RISC-V。`,
        isExamFocus: true
      }
    ]
  },
  "2.3.6": { id: "2.3.6", type: "subsection", title: "2.3.6 MIPS 指令系统", keyPoints: [{ title: "MIPS", content: "经典的 RISC 架构。32个通用寄存器。三类指令格式：R型 (寄存器)、I型 (立即数)、J型 (跳转)。" }] },
  "2.3.7": { id: "2.3.7", type: "subsection", title: "2.3.7 ARM 指令系统", keyPoints: [{ title: "ARM", content: "移动端霸主。特点是大多数指令支持条件执行 (Conditional Execution)，减少分支跳转。" }] }
};
